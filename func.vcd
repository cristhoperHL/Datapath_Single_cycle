$date
	Thu Mar 26 19:05:29 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module datapath $end
$var wire 5 ! write_reg [4:0] $end
$var wire 32 " read_data2 [31:0] $end
$var wire 32 # read_data1 [31:0] $end
$var wire 32 $ pc [31:0] $end
$var wire 1 % jump $end
$var wire 32 & instruction [31:0] $end
$var wire 32 ' d [31:0] $end
$var wire 6 ( alu_control_out [5:0] $end
$var wire 1 ) RegWrite $end
$var wire 1 * RegDst $end
$var wire 1 + MemtoReg $end
$var wire 1 , MemWrite $end
$var wire 1 - MemRead $end
$var wire 1 . Branch $end
$var wire 1 / ALUSrc $end
$var wire 6 0 ALUOP [5:0] $end
$var reg 1 1 clk $end
$var reg 1 2 reset $end
$scope module AC $end
$var wire 6 3 func [5:0] $end
$var wire 6 4 ALUOP [5:0] $end
$var reg 6 5 alu_control_out [5:0] $end
$upscope $end
$scope module APC $end
$var wire 32 6 pc [31:0] $end
$var reg 32 7 pc_end [31:0] $end
$upscope $end
$scope module CU $end
$var wire 6 8 instruction [5:0] $end
$var reg 6 9 ALUOP [5:0] $end
$var reg 1 / ALUSrc $end
$var reg 1 . Branch $end
$var reg 1 - MemRead $end
$var reg 1 , MemWrite $end
$var reg 1 + MemtoReg $end
$var reg 1 * RegDst $end
$var reg 1 ) RegWrite $end
$var reg 1 % jump $end
$upscope $end
$scope module IM $end
$var wire 32 : pc [31:0] $end
$var reg 32 ; out [31:0] $end
$upscope $end
$scope module PC $end
$var wire 1 1 clk $end
$var wire 32 < d [31:0] $end
$var wire 1 2 reset $end
$var reg 32 = q [31:0] $end
$upscope $end
$scope module RF $end
$var wire 1 ) RegWrite $end
$var wire 1 1 clk $end
$var wire 5 > read_reg1 [4:0] $end
$var wire 5 ? read_reg2 [4:0] $end
$var wire 5 @ write_reg [4:0] $end
$var reg 32 A read_data1 [31:0] $end
$var reg 32 B read_data2 [31:0] $end
$upscope $end
$scope module rgm2_1 $end
$var wire 5 C a [4:0] $end
$var wire 5 D b [4:0] $end
$var wire 1 * sel $end
$var reg 5 E y [4:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 E
b1 D
b0 C
b10 B
b1 A
b0 @
b1 ?
b0 >
b0 =
b100 <
b10000000000000000 ;
b0 :
b111111 9
b0 8
b100 7
b0 6
b0 5
b111111 4
b0 3
12
11
b111111 0
0/
0.
0-
0,
0+
0*
0)
b0 (
b100 '
b10000000000000000 &
0%
b0 $
b1 #
b10 "
b0 !
$end
#1
02
01
#2
b100 "
b100 B
b11 #
b11 A
b1 (
b1 5
b10 !
b10 @
b10 E
b1 3
b11 ?
b10 >
b11 D
b10 C
b10000110000000000000001 &
b10000110000000000000001 ;
b1000 '
b1000 7
b1000 <
b100 $
b100 6
b100 :
b100 =
11
#3
01
#4
b110 "
b110 B
b101 #
b101 A
b10 (
b10 5
b100 !
b100 @
b100 E
b10 3
b101 ?
b100 >
b101 D
b100 C
b100001010000000000000010 &
b100001010000000000000010 ;
b1100 '
b1100 7
b1100 <
b1000 $
b1000 6
b1000 :
b1000 =
11
#5
01
#6
b1000 "
b1000 B
b111 #
b111 A
b11 (
b11 5
b110 !
b110 @
b110 E
b11 3
b111 ?
b110 >
b111 D
b110 C
b110001110000000000000011 &
b110001110000000000000011 ;
b10000 '
b10000 7
b10000 <
b1100 $
b1100 6
b1100 :
b1100 =
11
#7
01
#8
b1010 "
b1010 B
b1001 #
b1001 A
b100 (
b100 5
b1000 !
b1000 @
b1000 E
b100 3
b1001 ?
b1000 >
b1001 D
b1000 C
b1000010010000000000000100 &
b1000010010000000000000100 ;
b10100 '
b10100 7
b10100 <
b10000 $
b10000 6
b10000 :
b10000 =
11
#9
01
#10
b1100 "
b1100 B
b1011 #
b1011 A
b0 (
b0 5
b1010 !
b1010 @
b1010 E
b0 3
b1011 ?
b1010 >
b1011 D
b1010 C
b1010010110000000000000000 &
b1010010110000000000000000 ;
b11000 '
b11000 7
b11000 <
b10100 $
b10100 6
b10100 :
b10100 =
11
#11
01
