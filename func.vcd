$date
	Sat Mar 28 22:18:40 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module datapath $end
$var wire 5 ! write_reg [4:0] $end
$var wire 32 " sign_extend_out [31:0] $end
$var wire 32 # read_data2 [31:0] $end
$var wire 32 $ read_data1 [31:0] $end
$var wire 32 % pc [31:0] $end
$var wire 1 & jump $end
$var wire 32 ' instruction [31:0] $end
$var wire 32 ( data_2_out [31:0] $end
$var wire 32 ) d [31:0] $end
$var wire 6 * alu_control_out [5:0] $end
$var wire 1 + RegWrite $end
$var wire 1 , RegDst $end
$var wire 1 - MemtoReg $end
$var wire 1 . MemWrite $end
$var wire 1 / MemRead $end
$var wire 1 0 Branch $end
$var wire 32 1 ALU_result [31:0] $end
$var wire 1 2 ALUSrc $end
$var wire 6 3 ALUOP [5:0] $end
$var reg 1 4 clk $end
$var reg 1 5 reset $end
$scope module AC $end
$var wire 6 6 func [5:0] $end
$var wire 6 7 ALUOP [5:0] $end
$var reg 6 8 alu_control_out [5:0] $end
$upscope $end
$scope module APC $end
$var wire 32 9 pc [31:0] $end
$var reg 32 : pc_end [31:0] $end
$upscope $end
$scope module CU $end
$var wire 6 ; instruction [5:0] $end
$var reg 6 < ALUOP [5:0] $end
$var reg 1 2 ALUSrc $end
$var reg 1 0 Branch $end
$var reg 1 / MemRead $end
$var reg 1 . MemWrite $end
$var reg 1 - MemtoReg $end
$var reg 1 , RegDst $end
$var reg 1 + RegWrite $end
$var reg 1 & jump $end
$upscope $end
$scope module IM $end
$var wire 32 = pc [31:0] $end
$var reg 32 > out [31:0] $end
$upscope $end
$scope module PC $end
$var wire 1 4 clk $end
$var wire 32 ? d [31:0] $end
$var wire 1 5 reset $end
$var reg 32 @ q [31:0] $end
$upscope $end
$scope module RF $end
$var wire 1 + RegWrite $end
$var wire 1 4 clk $end
$var wire 32 A read_data1 [31:0] $end
$var wire 32 B read_data2 [31:0] $end
$var wire 5 C read_reg1 [4:0] $end
$var wire 5 D read_reg2 [4:0] $end
$var wire 5 E write_reg [4:0] $end
$var wire 32 F write_data [31:0] $end
$upscope $end
$scope module SE $end
$var wire 16 G instruction_in [15:0] $end
$var wire 32 H instruction_out [31:0] $end
$upscope $end
$scope module alu $end
$var wire 6 I alu_control_out [5:0] $end
$var wire 32 J read_data1 [31:0] $end
$var wire 32 K read_data2 [31:0] $end
$var reg 32 L ALU_result [31:0] $end
$upscope $end
$scope module alu_mux $end
$var wire 32 M a [31:0] $end
$var wire 32 N b [31:0] $end
$var wire 1 2 sel $end
$var wire 32 O y [31:0] $end
$upscope $end
$scope module rgm2_1 $end
$var wire 5 P a [4:0] $end
$var wire 5 Q b [4:0] $end
$var wire 1 , sel $end
$var reg 5 R y [4:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 R
b0 Q
b1 P
b10 O
b0 N
b10 M
b11 L
b10 K
b1 J
b0 I
b0 H
b0 G
b11 F
b0 E
b1 D
b0 C
b10 B
b1 A
b0 @
b100 ?
b10000000000000000 >
b0 =
b111111 <
b0 ;
b100 :
b0 9
b0 8
b111111 7
b0 6
15
14
b111111 3
02
b11 1
00
0/
0.
0-
0,
1+
b0 *
b100 )
b10 (
b10000000000000000 '
0&
b0 %
b1 $
b10 #
b0 "
b0 !
$end
#1
05
04
#2
b1 *
b1 8
b1 I
b1 !
b1 E
b1 R
b100000000001 "
b100000000001 H
b100000000001 N
b100000000001 G
b1 6
b1 Q
b10000100000000001 '
b10000100000000001 >
b1000 )
b1000 :
b1000 ?
b1 1
b1 F
b1 L
b100 %
b100 9
b100 =
b100 @
b11 $
b11 A
b11 J
14
#3
04
#4
b10 *
b10 8
b10 I
b10 !
b10 E
b10 R
b1000000000010 "
b1000000000010 H
b1000000000010 N
b1000000000010 G
b10 6
b10 D
b1 $
b1 A
b1 J
b1 C
b10 Q
b10 P
b1000100001000000000010 '
b1000100001000000000010 >
b1 1
b1 F
b1 L
b1100 )
b1100 :
b1100 ?
b11 (
b11 K
b11 O
b1000 %
b1000 9
b1000 =
b1000 @
b11 #
b11 B
b11 M
14
#5
04
#6
b11111111111111111111111111111010 1
b11111111111111111111111111111010 F
b11111111111111111111111111111010 L
b11 *
b11 8
b11 I
b11 !
b11 E
b11 R
b1100000000011 "
b1100000000011 H
b1100000000011 N
b1100000000011 G
b11 6
b11 D
b10 C
b11 Q
b11 P
b10000110001100000000011 '
b10000110001100000000011 >
b10000 )
b10000 :
b10000 ?
b100 (
b100 K
b100 O
b1100 %
b1100 9
b1100 =
b1100 @
b100 #
b100 B
b100 M
14
#7
04
#8
b100 *
b100 8
b100 I
b100 !
b100 E
b100 R
b10000000000100 "
b10000000000100 H
b10000000000100 N
b10000000000100 G
b100 6
b100 D
b11111111111111111111111111111010 $
b11111111111111111111111111111010 A
b11111111111111111111111111111010 J
b11 C
b100 Q
b100 P
b11001000010000000000100 '
b11001000010000000000100 >
b11111111111111111111111111111111 1
b11111111111111111111111111111111 F
b11111111111111111111111111111111 L
b10100 )
b10100 :
b10100 ?
b101 (
b101 K
b101 O
b10000 %
b10000 9
b10000 =
b10000 @
b101 #
b101 B
b101 M
14
#9
04
#10
b0 1
b0 F
b0 L
b101 *
b101 8
b101 I
b101 !
b101 E
b101 R
b10100000000101 "
b10100000000101 H
b10100000000101 N
b10100000000101 G
b101 6
b101 D
b11111111111111111111111111111111 $
b11111111111111111111111111111111 A
b11111111111111111111111111111111 J
b100 C
b101 Q
b101 P
b100001010010100000000101 '
b100001010010100000000101 >
b11000 )
b11000 :
b11000 ?
b110 (
b110 K
b110 O
b10100 %
b10100 9
b10100 =
b10100 @
b110 #
b110 B
b110 M
14
#11
04
#12
12
b110 3
b110 7
b110 <
1,
b1010 1
b1010 F
b1010 L
b110 *
b110 8
b110 I
b0 !
b0 E
b0 R
b111 "
b111 H
b111 N
b111 G
b111 6
b0 D
b11 $
b11 A
b11 J
b0 C
b0 Q
b0 P
b110 ;
b11000000000000000000000000111 '
b11000000000000000000000000111 >
b11100 )
b11100 :
b11100 ?
b111 (
b111 K
b111 O
b11000 %
b11000 9
b11000 =
b11000 @
b11 #
b11 B
b11 M
14
#13
04
#14
b111 *
b111 8
b111 I
b111 3
b111 7
b111 <
b101 (
b101 K
b101 O
b1 !
b1 E
b1 R
b101 "
b101 H
b101 N
b101 G
b101 6
b1 D
b1 P
b111 ;
b11100000000010000000000000101 '
b11100000000010000000000000101 >
b100000 )
b100000 :
b100000 ?
b0 1
b0 F
b0 L
b11100 %
b11100 9
b11100 =
b11100 @
b1010 $
b1010 A
b1010 J
b1 #
b1 B
b1 M
14
#15
04
#16
b11111111111111111111111111111101 1
b11111111111111111111111111111101 F
b11111111111111111111111111111101 L
b1000 *
b1000 8
b1000 I
b1000 3
b1000 7
b1000 <
b11 (
b11 K
b11 O
b10 !
b10 E
b10 R
b11 "
b11 H
b11 N
b11 G
b11 6
b10 D
b0 $
b0 A
b0 J
b1 C
b10 P
b1000 ;
b100000001000100000000000000011 '
b100000001000100000000000000011 >
b100100 )
b100100 :
b100100 ?
b100000 %
b100000 9
b100000 =
b100000 @
b1 #
b1 B
b1 M
14
#17
04
#18
b1001 *
b1001 8
b1001 I
b1001 3
b1001 7
b1001 <
b1000 (
b1000 K
b1000 O
b11111111111111111111111111111101 1
b11111111111111111111111111111101 F
b11111111111111111111111111111101 L
b11 !
b11 E
b11 R
b1000 "
b1000 H
b1000 N
b1000 G
b1000 6
b11 D
b11111111111111111111111111111101 $
b11111111111111111111111111111101 A
b11111111111111111111111111111101 J
b10 C
b11 P
b1001 ;
b100100010000110000000000001000 '
b100100010000110000000000001000 >
b101000 )
b101000 :
b101000 ?
b100100 %
b100100 9
b100100 =
b100100 @
b11111111111111111111111111111010 #
b11111111111111111111111111111010 B
b11111111111111111111111111111010 M
14
#19
04
#20
b0 1
b0 F
b0 L
b1101 *
b1101 8
b1101 I
b1101 3
b1101 7
b1101 <
b101 (
b101 K
b101 O
b100 !
b100 E
b100 R
b101 "
b101 H
b101 N
b101 G
b101 6
b100 D
b11 C
b100 P
b1101 ;
b110100011001000000000000000101 '
b110100011001000000000000000101 >
b101100 )
b101100 :
b101100 ?
b101000 %
b101000 9
b101000 =
b101000 @
b11111111111111111111111111111111 #
b11111111111111111111111111111111 B
b11111111111111111111111111111111 M
14
#21
04
