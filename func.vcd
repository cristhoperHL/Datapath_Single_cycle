$date
	Fri Mar 27 09:59:08 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module datapath $end
$var wire 5 ! write_reg [4:0] $end
$var wire 32 " read_data2 [31:0] $end
$var wire 32 # read_data1 [31:0] $end
$var wire 32 $ pc [31:0] $end
$var wire 1 % jump $end
$var wire 32 & instruction [31:0] $end
$var wire 32 ' d [31:0] $end
$var wire 6 ( alu_control_out [5:0] $end
$var wire 1 ) RegWrite $end
$var wire 1 * RegDst $end
$var wire 1 + MemtoReg $end
$var wire 1 , MemWrite $end
$var wire 1 - MemRead $end
$var wire 1 . Branch $end
$var wire 32 / ALU_result [31:0] $end
$var wire 1 0 ALUSrc $end
$var wire 6 1 ALUOP [5:0] $end
$var reg 1 2 clk $end
$var reg 1 3 reset $end
$scope module AC $end
$var wire 6 4 func [5:0] $end
$var wire 6 5 ALUOP [5:0] $end
$var reg 6 6 alu_control_out [5:0] $end
$upscope $end
$scope module APC $end
$var wire 32 7 pc [31:0] $end
$var reg 32 8 pc_end [31:0] $end
$upscope $end
$scope module CU $end
$var wire 6 9 instruction [5:0] $end
$var reg 6 : ALUOP [5:0] $end
$var reg 1 0 ALUSrc $end
$var reg 1 . Branch $end
$var reg 1 - MemRead $end
$var reg 1 , MemWrite $end
$var reg 1 + MemtoReg $end
$var reg 1 * RegDst $end
$var reg 1 ) RegWrite $end
$var reg 1 % jump $end
$upscope $end
$scope module IM $end
$var wire 32 ; pc [31:0] $end
$var reg 32 < out [31:0] $end
$upscope $end
$scope module PC $end
$var wire 1 2 clk $end
$var wire 32 = d [31:0] $end
$var wire 1 3 reset $end
$var reg 32 > q [31:0] $end
$upscope $end
$scope module RF $end
$var wire 1 ) RegWrite $end
$var wire 1 2 clk $end
$var wire 32 ? read_data1 [31:0] $end
$var wire 32 @ read_data2 [31:0] $end
$var wire 5 A read_reg1 [4:0] $end
$var wire 5 B read_reg2 [4:0] $end
$var wire 5 C write_reg [4:0] $end
$var wire 32 D write_data [31:0] $end
$upscope $end
$scope module alu $end
$var wire 6 E alu_control_out [5:0] $end
$var wire 32 F read_data1 [31:0] $end
$var wire 32 G read_data2 [31:0] $end
$var reg 32 H ALU_result [31:0] $end
$upscope $end
$scope module rgm2_1 $end
$var wire 5 I a [4:0] $end
$var wire 5 J b [4:0] $end
$var wire 1 * sel $end
$var reg 5 K y [4:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 K
b0 J
b1 I
b11 H
b10 G
b1 F
b0 E
b11 D
b0 C
b1 B
b0 A
b10 @
b1 ?
b0 >
b100 =
b10000000000000000 <
b0 ;
b111111 :
b0 9
b100 8
b0 7
b0 6
b111111 5
b0 4
13
12
b111111 1
00
b11 /
0.
0-
0,
0+
0*
1)
b0 (
b100 '
b10000000000000000 &
0%
b0 $
b1 #
b10 "
b0 !
$end
#1
03
02
#2
b1 (
b1 6
b1 E
b1 4
b100 "
b100 @
b100 G
b11 B
b11 I
b110000000000000001 &
b110000000000000001 <
b1000 '
b1000 8
b1000 =
b11111111111111111111111111111111 /
b11111111111111111111111111111111 D
b11111111111111111111111111111111 H
b100 $
b100 7
b100 ;
b100 >
b11 #
b11 ?
b11 F
12
#3
02
#4
b10 (
b10 6
b10 E
b10 4
b110 "
b110 @
b110 G
b101 B
b101 I
b1010000000000000010 &
b1010000000000000010 <
b1100 '
b1100 8
b1100 =
b110 /
b110 D
b110 H
b1000 $
b1000 7
b1000 ;
b1000 >
b11111111111111111111111111111111 #
b11111111111111111111111111111111 ?
b11111111111111111111111111111111 F
12
#5
02
#6
b11 (
b11 6
b11 E
b11111111111111111111111111110001 /
b11111111111111111111111111110001 D
b11111111111111111111111111110001 H
b11 4
b1000 "
b1000 @
b1000 G
b111 B
b111 I
b1110000000000000011 &
b1110000000000000011 <
b10000 '
b10000 8
b10000 =
b1100 $
b1100 7
b1100 ;
b1100 >
b110 #
b110 ?
b110 F
12
#7
02
#8
b100 (
b100 6
b100 E
b100 4
b1010 "
b1010 @
b1010 G
b1001 B
b1000 A
b1001 I
b1000010010000000000000100 &
b1000010010000000000000100 <
b10100 '
b10100 8
b10100 =
b1011 /
b1011 D
b1011 H
b10000 $
b10000 7
b10000 ;
b10000 >
b1001 #
b1001 ?
b1001 F
12
#9
02
#10
b0 (
b0 6
b0 E
b10111 /
b10111 D
b10111 H
b0 4
b1100 "
b1100 @
b1100 G
b1011 B
b1011 #
b1011 ?
b1011 F
b1010 A
b1011 I
b1010010110000000000000000 &
b1010010110000000000000000 <
b11000 '
b11000 8
b11000 =
b10100 $
b10100 7
b10100 ;
b10100 >
12
#11
02
