$date
	Thu Mar 26 20:25:30 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module datapath $end
$var wire 5 ! write_reg [4:0] $end
$var wire 32 " read_data2 [31:0] $end
$var wire 32 # read_data1 [31:0] $end
$var wire 32 $ pc [31:0] $end
$var wire 1 % jump $end
$var wire 32 & instruction [31:0] $end
$var wire 32 ' d [31:0] $end
$var wire 6 ( alu_control_out [5:0] $end
$var wire 1 ) RegWrite $end
$var wire 1 * RegDst $end
$var wire 1 + MemtoReg $end
$var wire 1 , MemWrite $end
$var wire 1 - MemRead $end
$var wire 1 . Branch $end
$var wire 32 / ALU_result [31:0] $end
$var wire 1 0 ALUSrc $end
$var wire 6 1 ALUOP [5:0] $end
$var reg 1 2 clk $end
$var reg 1 3 reset $end
$scope module AC $end
$var wire 6 4 func [5:0] $end
$var wire 6 5 ALUOP [5:0] $end
$var reg 6 6 alu_control_out [5:0] $end
$upscope $end
$scope module APC $end
$var wire 32 7 pc [31:0] $end
$var reg 32 8 pc_end [31:0] $end
$upscope $end
$scope module CU $end
$var wire 6 9 instruction [5:0] $end
$var reg 6 : ALUOP [5:0] $end
$var reg 1 0 ALUSrc $end
$var reg 1 . Branch $end
$var reg 1 - MemRead $end
$var reg 1 , MemWrite $end
$var reg 1 + MemtoReg $end
$var reg 1 * RegDst $end
$var reg 1 ) RegWrite $end
$var reg 1 % jump $end
$upscope $end
$scope module IM $end
$var wire 32 ; pc [31:0] $end
$var reg 32 < out [31:0] $end
$upscope $end
$scope module PC $end
$var wire 1 2 clk $end
$var wire 32 = d [31:0] $end
$var wire 1 3 reset $end
$var reg 32 > q [31:0] $end
$upscope $end
$scope module RF $end
$var wire 1 ) RegWrite $end
$var wire 1 2 clk $end
$var wire 5 ? read_reg1 [4:0] $end
$var wire 5 @ read_reg2 [4:0] $end
$var wire 5 A write_reg [4:0] $end
$var reg 32 B read_data1 [31:0] $end
$var reg 32 C read_data2 [31:0] $end
$upscope $end
$scope module alu $end
$var wire 6 D alu_control_out [5:0] $end
$var wire 32 E read_data1 [31:0] $end
$var wire 32 F read_data2 [31:0] $end
$var reg 32 G ALU_result [31:0] $end
$upscope $end
$scope module rgm2_1 $end
$var wire 5 H a [4:0] $end
$var wire 5 I b [4:0] $end
$var wire 1 * sel $end
$var reg 5 J y [4:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 J
b1 I
b0 H
b11 G
b10 F
b1 E
b0 D
b10 C
b1 B
b0 A
b1 @
b0 ?
b0 >
b100 =
b10000000000000000 <
b0 ;
b111111 :
b0 9
b100 8
b0 7
b0 6
b111111 5
b0 4
13
12
b111111 1
00
b11 /
0.
0-
0,
0+
0*
0)
b0 (
b100 '
b10000000000000000 &
0%
b0 $
b1 #
b10 "
b0 !
$end
#1
03
02
#2
b100 "
b100 C
b100 F
b11 #
b11 B
b11 E
b11111111111111111111111111111111 /
b11111111111111111111111111111111 G
b1 (
b1 6
b1 D
b10 !
b10 A
b10 J
b1 4
b11 @
b10 ?
b11 I
b10 H
b10000110000000000000001 &
b10000110000000000000001 <
b1000 '
b1000 8
b1000 =
b100 $
b100 7
b100 ;
b100 >
12
#3
02
#4
b110 "
b110 C
b110 F
b101 #
b101 B
b101 E
b100 /
b100 G
b10 (
b10 6
b10 D
b100 !
b100 A
b100 J
b10 4
b101 @
b100 ?
b101 I
b100 H
b100001010000000000000010 &
b100001010000000000000010 <
b1100 '
b1100 8
b1100 =
b1000 $
b1000 7
b1000 ;
b1000 >
12
#5
02
#6
b1000 "
b1000 C
b1000 F
b111 #
b111 B
b111 E
b11111111111111111111111111110000 /
b11111111111111111111111111110000 G
b11 (
b11 6
b11 D
b110 !
b110 A
b110 J
b11 4
b111 @
b110 ?
b111 I
b110 H
b110001110000000000000011 &
b110001110000000000000011 <
b10000 '
b10000 8
b10000 =
b1100 $
b1100 7
b1100 ;
b1100 >
12
#7
02
#8
b1010 "
b1010 C
b1010 F
b1001 #
b1001 B
b1001 E
b1011 /
b1011 G
b100 (
b100 6
b100 D
b1000 !
b1000 A
b1000 J
b100 4
b1001 @
b1000 ?
b1001 I
b1000 H
b1000010010000000000000100 &
b1000010010000000000000100 <
b10100 '
b10100 8
b10100 =
b10000 $
b10000 7
b10000 ;
b10000 >
12
#9
02
#10
b1100 "
b1100 C
b1100 F
b1011 #
b1011 B
b1011 E
b10111 /
b10111 G
b0 (
b0 6
b0 D
b1010 !
b1010 A
b1010 J
b0 4
b1011 @
b1010 ?
b1011 I
b1010 H
b1010010110000000000000000 &
b1010010110000000000000000 <
b11000 '
b11000 8
b11000 =
b10100 $
b10100 7
b10100 ;
b10100 >
12
#11
02
